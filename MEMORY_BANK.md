# Memory Bank: בניית Document DB ב-Rust

מסמך זה מתעד את ההתקדמות, המושגים שנלמדו, וההחלטות העיצוביות שהתקבלו במהלך בניית מסד נתונים מבוסס מסמכים ב-Rust.

## תפקיד המורה (Coding Teacher)

*   **עקרון הדרכה**: המורה מדריך את הלמיד אך לא מבצע עבורו את המשימות. הלמיד הוא זה שצריך לבצע את העבודה בפועל.
*   **גישת הוראה**: שימוש בשאלות מכוונות כדי להנחות את הלמיד לגילוי עצמי של מושגים.
*   **קצב למידה**: התקדמות הדרגתית עם בדיקת הבנה לאחר כל שלב.
*   **אחריות**: על המורה להיזכר בתפקידו כמנחה ולא לבצע את העבודה במקום הלמיד.

## החלטות ארכיטקטוניות

*   **`DataBase` -> `Collection`**: הוחלט לשנות את שם מבנה הנתונים הראשי מ-`DataBase` ל-`Collection`. זה משקף בצורה מדויקת יותר את המודל המקובל במסדי נתונים מבוססי מסמכים.
*   **פישוט API**: הוסרה הפונקציה `from_hashmap` והפונקציה `new` פושטה, בהתאם לעיקרון YAGNI (You Ain't Gonna Need It) כדי לשמור על הקוד נקי וממוקד.

*   **שימוש בנעילת כתיבה לפעולות קריאה** (זמני): הוחלט להשתמש ב-`RwLockWriteGuard` גם לפעולות קריאה כדי לאפשר mutable reference הנדרש לפעולות קריאה/כתיבה. זוהי פשרה זמנית שחוסמת קריאות מקביליות, אך מבטיחה תקינות. יש למצוא פתרון יצירתי להמשך.

*   **שימוש ב-`Option<BlockSeek>` במקום enum נפרד**: הוחלט להשתמש ב-`Option<BlockSeek>` לטיפול במצב של סוף השרשרת, במקום להגדיר וריאנט נפרד ב-enum. זה פישט את הקוד והפך אותו לאלגנטי יותר.

## מושגי מפתח שנלמדו ויושמו בהצלחה

1.  **ניהול פרויקט עם Cargo**:
    *   יצירת פרויקט חדש (`cargo new`).
    *   קומפילציה והרצה (`cargo run`).
    *   שימוש ב-`.gitignore` סטנדרטי לפרויקטי Rust.

2.  **בדיקות יחידה (Unit Testing)**:
    *   העברת כל לוגיקת הבדיקה מפונקציית `main` למודול בדיקות ייעודי (`#[cfg(test)] mod tests`).
    *   הרצת בדיקות באמצעות `cargo test`.
    *   שימוש במאקרואים `assert_eq!` ו-`assert!` לאימות התנהגות נכונה.
    *   כתיבת בדיקות למקרי קצה ושגיאות (למשל, פעולה על מפתח לא קיים).
    *   שימוש במאקרו `matches!` לבדיקת וריאנטים ספציפיים של `enum` בתוצאות שגיאה.
    *   שימוש בבדיקות לאיתור ותיקון באגים (Red-Green-Refactor).

3.  **מבני נתונים ו-API**:
    *   הגדרת `struct` ו-`enum`.
    *   שימוש ב-`HashMap` ומתודות הליבה שלו (`get`, `get_mut`, `insert`, `remove`).

4.  **בעלות והשאלות (Ownership & Borrowing)**:
    *   הבנה והבחנה ברורה בין סוגי `self` (`&self`, `&mut self`).
    *   פתרון שגיאת קומפילציה קלאסית (E0502) של השאלה כפולה (immutable vs. mutable borrow) באמצעות `.clone()` לשחרור השאלה.
    *   הבנת השימוש ב-`*` (dereference) לעדכון ערך דרך רפרנס משתנה.

5.  **טיפול בתוצאות ושגיאות**:
    *   שימוש ב-`Option<T>`, `Result<T, E>`, והתבנית `Result<Option<T>, E>`.
    *   שימוש בטוח ב-`match` ו-`if let` לטיפול בתוצאות.
    *   הגדרת `enum` מותאמים אישית לטיפול בשגיאות (`ReaderError`, `WriterError`).
    *   יישום `From` traits להמרת שגיאות בין סוגים שונים.

6.  **תכנות מערכות (Systems Programming)**:
    *   עבודה עם קבצים בינאריים וסריאליזציה.
    *   הבנת המגבלות של נעילות קריאה/כתיבה (`RwLock`) בהקשר של פעולות קריאה/כתיבה.
    *   תכנון מערכת אחסון מבוסס בלוקים עם שרשרת בלוקים.
    *   הבנה עמוקה של borrowing semantics ב-Rust ובעיות concurrent access.

## API הליבה שפותח (CRUD)

פותח API מלא ונקי עבור `Collection`, המכוסה במלואו על ידי בדיקות יחידה:

*   **Create**: `fn write(&mut self, value: String) -> Result<u64, OperationError>`
*   **Read**: `fn read(&self, key: u64) -> Result<Option<&String>, OperationError>`
*   **Update**: `fn update(&mut self, key: u64, new_value: &String) -> Result<u64, OperationError>`
*   **Delete**: `fn delete(&mut self, key: u64) -> Result<String, OperationError>`

## תכנון מערכת האחסון

### החלטות ארכיטקטוניות למימוש הבלוקים

1. **מבנה BlockStorage** - ינהל את כל הפעולות על קבצי הבלוקים
2. **פונקציות לקריאה/כתיבה של רצף בלוקים** - לטיפול בנתונים גדולים שמתפרסים על פני מספר בלוקים
3. **בלוק ייעודי לניהול שטח פנוי** - עם מערך של מיקומים פנויים
4. **בלוק אינדקס ייעודי** - עם מערך של מיקומי בלוקים לחיפוש מהיר

### מבנה הבלוק הנוכחי

*   **גודל בלוק**: 1024 בתים (8 בתים למזהה, 1008 בתים לנתונים, 8 בתים למיקום הבלוק הבא)
*   **סוגי בלוקים**:
    *   בלוק נתונים רגיל (id > 0)
    *   בלוק מחוק (id = 0)
    *   בלוק אינדקס (id = u64::MAX)

### יישום שנעשה

*   **פונקציות לקריאה/כתיבה של רצף בלוקים** ✅
    *   יישום `read_full_item()` לקריאת נתונים המתפרסים על פני מספר בלוקים
    *   מעקב אחר שרשרת בלוקים באמצעות `next_block_offset`
    *   טיפול נכון במצב של סוף השרשרת (`next_block_offset = 0`)
    *   בדיקות יחידה מקיפות לפונקציונליות החדשה

*   **הבנה עמוקה של בעיות נעילה** 🔄
    *   חקירת המגבלות של `RwLock` בהקשר של פעולות קריאה/כתיבה
    *   הבנת הצורך ב-mutable reference לפעולות קריאה
    *   זיהוי הצורך בפתרון יצירתי לבעיית הנעילה (נושא להמשך)

### תכנון להמשך

*   **מימוש בלוק ייעודי לניהול שטח פנוי** - מערכת לניהול בלוקים שנמחקו ומחזורם
*   **מימוש בלוק אינדקס ייעודי** - מבנה אינדקס לחיפוש מהיר בנתונים
*   **פתרון בעיות הנעילה** - מציאת דרך לאפשר קריאה מקבילית בטוחה
*   **שילוב המערכת עם Collection** - חיבור בין שכבת האחסון ל-API של המשתמש
